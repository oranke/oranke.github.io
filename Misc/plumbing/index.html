<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Plumbing test</title>

    <link rel="stylesheet" type="text/css" href="main.css?v=24">
    <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
    <script src="https://code.jquery.com/mobile/1.4.5/jquery.mobile-1.4.5.min.js"></script>
    
    <script src="./hammer.min.js"></script>

    <script>
        var camera_offset_y = 0.0;

        
        function getParam(sname) {
            var params = location.search.substr(location.search.indexOf("?") + 1);
            var sval = "";
            params = params.split("&");
            for (var i = 0; i < params.length; i++) {
                temp = params[i].split("=");
                if ([temp[0]] == sname) { sval = temp[1]; }
            }
            return sval;
        }

        function initApp() {
            //var bkwName = getParam('bkw');
            //if (bkwName.length == 0) bkwName = 'LotteCamical';

            function D2R( deg ) {
                return deg * Math.PI / 180;
            }

            Module.useDefaultMouseAction(false); 
            Module.setCameraRotSpeed_Fov(10, 100, 1);

            // Set camear pos to factory center
            //Module.setCameraPos(14.0, camera_offset_y, 10.0, false, false); 
            //Module.setCameraRotSpeed_Fov(10, 100, 1);
            var canvas = document.getElementById('canvas'); 

            
            var hammer = new Hammer(canvas);

            hammer.get('pinch').set({ enable: true });
            hammer.get('rotate').set({ enable: true });
            hammer.get('pan').set({ direction: Hammer.DIRECTION_ALL });

            hammer.on('tap', function(ev) {
                //console.log('tap', ev);   
                // 선택된 블럭 회전
                if (Array.isArray(ev.changedPointers) && ev.changedPointers.length > 0)
                {
                    var hitInfo = 
                        Module.getHitInfo(
                            ev.changedPointers[0].offsetX,
                            ev.changedPointers[0].offsetY
                        )
                    if (hitInfo) {
                        hitInfo.rotate();
                        hitInfo.delete();
                    }
                }
            })

            hammer.on('press', function(ev) {
                //console.log('press', ev);   
                // 선택된 블럭을 화면 가운데로.
                if (Array.isArray(ev.changedPointers) && ev.changedPointers.length > 0)
                {
                    var hitInfo = 
                        Module.getHitInfo(
                            ev.changedPointers[0].offsetX,
                            ev.changedPointers[0].offsetY
                        )
                    if (hitInfo) {
                        //console.log(hitInfo.grid)
                        Module.setCameraPos(hitInfo.grid.x, 0.25, hitInfo.grid.y, true, false); 
                        hitInfo.delete();
                    }
                }
            })


            
            var lastScale = 1;
            hammer.on('pinchstart', function(ev){
                //console.log('pinchstart', ev);   
                lastScale = ev.scale; 
            })

            hammer.on('pinch', function(ev) {
                //console.log('pinch', ev);   
                //console.log('pinch', lastScale, ev.scale);
                if (ev && ev.scale) {
                    Module.setCameraRot_Fov( (lastScale - ev.scale) * 10, true, true );
                    lastScale = ev.scale; 
                }
            })
            
            //*
            var lastAngle = 0;
            hammer.on('rotatestart', function(ev) {
                //console.log('start', ev);
                lastAngle = ev.rotation; 

                lastScale = 1;
            })

            hammer.on('rotate', function(ev) {
                //console.log('rotate', initAngle, ev.rotation);   
                //Module.setCameraRot_Y( -ev.rotation, true, false);
                if (ev && ev.rotation) {
                    Module.setCameraRot_Y( lastAngle - ev.rotation, true, true);
                    lastAngle = ev.rotation;
                }
            })
            //*/

            var lastDownPos = undefined;
            hammer.on('panstart', function(ev) {
                //console.log('panstart', ev);   
                lastDownPos = ev.center; 

                lastAngle = 0;
                lastScale = 1;
            })

            hammer.on('pan', function(ev) {
                if (ev && ev.center) {
                    //console.log('pan', ev);   
                    var dx = ev.center.x - lastDownPos.x; 
                    var dy = ev.center.y - lastDownPos.y; 
                    //console.log(dx, dy); 

                    Module.setCameraRot_X( dy, true, true);
                    Module.setCameraRot_Y( dx, true, true);

                    lastDownPos = ev.center;
                }

            })


            //*
            // Set wheel event to zoom
            canvas.addEventListener("wheel", function(event) {
                //console.log('haha', event)
                //setSceneScale( event.deltaY ); 

                Module.setCameraRot_Fov( -event.deltaY / 50, true, true );

                event.preventDefault(); 
            }, {passive: false})
            //*/

            /*
            // Set mouse action
            //Module.useDefaultMouseAction(false); 

            var isDownForCamera = false; 
            var firstDownPos = undefined; 
            var lastDownPos = undefined; 


            canvas.onpointerdown = function(event) {
                event.preventDefault(); 
                event.target.setPointerCapture(event.pointerId);
                // console.log("MouseDown", event.offsetX, event.offsetY); 

                isDownForCamera = true; 
                firstDownPos = {
                    x: event.offsetX,
                    y: event.offsetY
                }

                lastDownPos = {
                    x: event.offsetX,
                    y: event.offsetY
                }
            }

            canvas.onpointerup = function(event) {
                event.target.releasePointerCapture(event.pointerId);

                if (isDownForCamera) {
                    isDownForCamera = false; 

                    var dx = event.offsetX - firstDownPos.x; 
                    var dy = event.offsetY - firstDownPos.y; 

                    if (dx * dx + dy * dy < 25) {

                    }

                }
                // console.log("MouseUp", event.offsetX, event.offsetY); 
            }

            canvas.onpointermove = function(event) {
                if (isDownForCamera) {
                    var dx = event.offsetX - lastDownPos.x; 
                    var dy = event.offsetY - lastDownPos.y; 
                    //console.log(dx, dy); 

                    //Module.setCameraRot_X( dy / 5.0 , true, true);
                    //Module.setCameraRot_Y( dx / 5.0 , true, true);

                    lastDownPos = {
                        x: event.offsetX,
                        y: event.offsetY
                    }
                }
            }
            */

            // Set browser resize event
            window.addEventListener('resize', function() {
                var canvas = document.getElementById('canvas');
                var w = canvas.clientWidth;
                var h = canvas.clientHeight;
                if (canvas.width  != w) canvas.width  = w;
                if (canvas.height != h) canvas.height = h;
                
                Module.setRenderSize(w, h);
            });

            $('#btn_sample_1').click(function(){
                Module.newGame(5, 5, 0);
            });

            $('#btn_sample_2').click(function(){
                Module.newGame(10, 10, 0);
            });
            
            $('#btn_sample_3').click(function(){
                Module.newGame(15, 15, 0);
            });

        }
    </script>



</head> 
<body>
    <div class="container">
        <h2>Plumbing game test</h2>
        <pre>
    pan   - rotate view
    pinch - zoom in / out
    tap   - block rotate
    press - block to center </pre>
        <button onclick="location.reload(true); ">Reload</button>
        <button id="btn_sample_1">Easy</button>
        <button id="btn_sample_2">Medium</button>
        <button id="btn_sample_3">Hard</button>
        <hr>
        <div class="emscripten" style="width: 100%; height: 60vw;">
            <canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()"></canvas>
                   
        </div>
        <textarea id="output" rows="5" readonly style=display:none></textarea>

        <hr>

        <br>
        <div class="emscripten" id="status">Downloading...</div>
        <div class="emscripten">
            <progress value="0" max="100" id="progress" hidden=1></progress>
        </div>
    </div>

    <script type='text/javascript'>
        var statusElement = document.getElementById('status');
        var progressElement = document.getElementById('progress');

        var Module = {
            preRun: [
                function(){
                    // console.log('Prerun 1');
                }
            ],
            postRun: [
                initApp,

                function(){
                    // console.log('Postrun 1');
                }
            ],

            print: (function() {
                var element = document.getElementById('output');
                if (element) element.value = ''; // clear browser cache
                return function(text) {
                    if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
                    // These replacements are necessary if you render to raw HTML
                    //text = text.replace(/&/g, "&amp;");
                    //text = text.replace(/</g, "&lt;");
                    //text = text.replace(/>/g, "&gt;");
                    //text = text.replace('\n', '<br>', 'g');

                    //console.log(text);

                    if (element) {
                        element.value += text + "\n";
                        element.scrollTop = element.scrollHeight; // focus on bottom
                    }
                };
            })(),
            printErr: function(text) {
                if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ');
                if (0) { // XXX disabled for safety typeof dump == 'function') {
                    dump(text + '\n'); // fast, straight to the real console
                } else {
                    console.error(text);
                }
            },
            canvas: (function() {
                var canvas = document.getElementById('canvas');

                // As a default initial behavior, pop up an alert when webgl context is lost. To make your
                // application robust, you may want to override this behavior before shipping!
                // See http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.15.2
                canvas.addEventListener("webglcontextlost", function(e) { alert('WebGL context lost. You will need to reload the page.'); e.preventDefault(); }, false);

                return canvas;
            })(),
            setStatus: function(text) {
                if (!Module.setStatus.last) Module.setStatus.last = { time: Date.now(), text: '' };
                if (text === Module.setStatus.text) return;
                var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
                var now = Date.now();
                if (m && now - Date.now() < 30) return; // if this is a progress update, skip it if too soon
                if (m) {
                    text = m[1];
                    progressElement.value = parseInt(m[2])*100;
                    progressElement.max = parseInt(m[4])*100;
                    progressElement.hidden = false;
                    //spinnerElement.hidden = false;
                } else {
                    progressElement.value = null;
                    progressElement.max = null;
                    progressElement.hidden = true;
                    //if (!text) spinnerElement.style.display = 'none';
                }
                statusElement.innerHTML = text;
            },
            totalDependencies: 0,
            monitorRunDependencies: function(left) {
                this.totalDependencies = Math.max(this.totalDependencies, left);
                Module.setStatus(left ? 'Preparing... (' + (this.totalDependencies-left) + '/' + this.totalDependencies + ')' : 'All downloads complete.');
            }
        };

        Module.setStatus('Downloading...');

        window.onerror = function(event) {
            // TODO: do not warn on ok events like simulating an infinite loop or exitStatus
            Module.setStatus('Exception thrown, see JavaScript console');
            //spinnerElement.style.display = 'none';
            Module.setStatus = function(text) {
                if (text) Module.printErr('[post-exception status] ' + text);
            };
        };
        
    </script>
    <script async type="text/javascript" src="plumbing.js?v=23"></script>

</body>
</html>